Consider this example. Let's say you're an executive chef for a large chain of restaurants that serve pasta. You want the dishes to be consistent at all the restaurant locations in the chain, so you provide instructions for making each dish. Your two most popular dishes are spaghetti with tomato sauce and meatballs and penne noodles with Alfredo sauce and chicken. Both dishes require that you boil water, cook the pasta, add the sauce, add the protein, and garnish the plate. Some of these steps are implemented differently depending on what dish you're making. Each dish has a different protein, sauce, and garnish. So those would be implemented accordingly. Other steps would be implemented the same for both dishes. Both dishes require water to be boiled. Water can only be boiled a singular way regardless of the type of dish being made. You can model this situation with a pasta dish class with a method that makes the recipe for each subclass, spaghetti with meatballs or penne Alfredo. The method knows the general set of steps to make either dish from boiling water to adding the garnish. Steps that are special to a dish, like the sauce to add, are implemented in its subclass. These are all elements of the template method pattern. Which is the design pattern we will be talking about next. The template method defines an algorithm's steps generally, deferring the implementation of some steps to subclasses. It is a behavioral design pattern and is concerned with the assignment of responsibilities.

Now, let's take a look at how we might create the UML for the template method pattern. Let's go back to our pasta example. We have the PastaDish superclass with a template method, makeRecipe which calls other methods for the steps of the recipe. Some steps are common across specific dishes like boiling water, so boilWater is a method of PastaDish. However, some steps are special to dish like adding the sauce. So addSauce is an abstract method of PastaDish, it will be up to a subclass of pasta dish to provide the addSauce method body to add the right sauce. SpaghettiMeatballs and PenneAlfredo are subclasses of the PastaDish class. They must provide their own versions of addPasta, addSauce, addProtein, and addGarnish.

![Uml Diagram](https://github.com/shadhin/OOD/blob/master/resource/images/template_method_pattern.png "")

The template method can be helpful if you have two classes with similar functionality. When you notice two classes with a very similar order of operations, you can choose to use a template method. The template method pattern is a practical application of generalization and inheritance. When writing software, you might notice two separate classes that share similarities like each having a method with a very similar algorithm. Rather than making changes to these algorithms in two places, you can consolidate the algorithms to one place within a template method of a superclass for the two classes. You generalize from two separate methods into one template method within a superclass which will be inherited by the two classes. The differences in the algorithms would be done through calls to abstract methods whose implementations are provided by the subclasses.
